% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/PCDFunctions.r
\name{runif.tetra}
\alias{runif.tetra}
\title{An object of class "Uniform"

Generation of Uniform Points in a tetrahedron}
\usage{
runif.tetra(k, th)
}
\arguments{
\item{k}{A positive integer representing the number of uniform points to be generated in the tetrahedron}

\item{th}{Four 3D points, stacked row-wise, each row representing a vertex of the tetrahedron}
}
\value{
A list with the elements
\item{type}{The type of the pattern from which points are to be generated}
\item{mtxt}{The "main" title for the plot of the point pattern}
\item{tess.points}{The vertices of the support of the uniformly generated points, it is the tetrahedron
th for this function}
\item{gen.points}{The output set of generated points uniformly in the tetrahedron, th.}
\item{out.region}{The outer region which contains the support region, NULL for this function.}
\item{desc.pat}{Description of the point pattern from which points are to be generated}
\item{num.points}{The vector of two numbers, which are the number of generated points and the number
of vertices of the support points (here it is 4).}
\item{txt4pnts}{Description of the two numbers in num.points}
\item{xlimit, ylimit, zlimit}{The ranges of the x-, y- and z-coordinates of the support, th}
}
\description{
Generates k points uniformly in the general tetrahedron th whose vertices are stacked row-wise
}
\examples{
A<-c(0,0,0); B<-c(1,0,0); C<-c(1/2,sqrt(3)/2,0); D<-c(1/2,sqrt(3)/6,sqrt(6)/3); P<-c(.1,.1,.1)
#A<-runif(3); B<-runif(3); C<-runif(3); D<-runif(3); P<-runif(3)
#A<-runif(3,1,100); B<-runif(3,1,100); C<-runif(3,1,100); D<-runif(3,1,100); P<-runif(3,1,100)
tetra<-rbind(A,B,C,D)

in.tetrahedron(P,tetra,boundary=FALSE)

in.tetrahedron(C,tetra,boundary=FALSE)
in.tetrahedron(C,tetra,boundary=TRUE)

n<-40
Dt<-cbind(runif(n),runif(n,0,sqrt(3)/2),runif(n,0,sqrt(6)/3))

in.tetra<-vector()
for (i in 1:n)
{in.tetra<-c(in.tetra,in.tetrahedron(Dt[i,],tetra,boundary=TRUE)$inside.tetra) }

in.tetra
Dt.tet<-Dt[in.tetra,]

Xlim<-range(tetra[,1],Dt[,1])
Ylim<-range(tetra[,2],Dt[,2])
Zlim<-range(tetra[,3],Dt[,3])
xd<-Xlim[2]-Xlim[1]
yd<-Ylim[2]-Ylim[1]
zd<-Zlim[2]-Zlim[1]

library(plot3D)
scatter3D(Dt[,1],Dt[,2],Dt[,3], phi =40,theta=40, bty = "g", pch = 20, cex = 1, ticktype = "detailed",
          xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05), zlim=Zlim+zd*c(-.05,.05))
#add the vertices of the tetrahedron
points3D(tetra[,1],tetra[,2],tetra[,3], add=TRUE)
points3D(Dt.tet[,1],Dt.tet[,2],Dt.tet[,3],pch=4, add=TRUE)
L<-rbind(A,A,A,B,B,C); R<-rbind(B,C,D,C,D,D)
segments3D(L[,1], L[,2], L[,3], R[,1], R[,2],R[,3], add=TRUE,lwd=2)

text3D(tetra[,1],tetra[,2],tetra[,3], labels=c("A","B","C","D"), add=TRUE)

in.tetrahedron(P,tetra)

dat.fr<-data.frame(a=tetra)
in.tetrahedron(P,dat.fr)

}
\seealso{
\code{\link{runif.stdtetra}} and \code{\link{runif.tri}}
}
