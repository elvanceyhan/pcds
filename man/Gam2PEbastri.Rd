% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/PCDFunctions.r
\name{Gam2PEbastri}
\alias{Gam2PEbastri}
\title{The indicator for two points being a dominating set for Proportional Edge Proximity Catch Digraphs
(PE-PCDs) - basic triangle case}
\usage{
Gam2PEbastri(pt1, pt2, Dt, r, c1, c2, M = c(1, 1, 1), rv1 = NULL,
  rv2 = NULL, ch.data.pnts = FALSE)
}
\arguments{
\item{pt1, pt2}{Two 2D points to be tested for constituting a dominating set of the PE-PCD}

\item{Dt}{A set of 2D points which constitutes the vertices of the PE-PCD}

\item{r}{A positive real number which serves as the expansion parameter in PE proximity region; must be >=1}

\item{c1, c2}{Positive real numbers which constitute the vertex of the basic triangle
adjacent to the shorter edges; c1 must be in [0,1/2], c2>0 and (1-c1)^2+c2^2 <=1}

\item{M}{A 2D point in Cartesian coordinates or a 3D point in barycentric coordinates
which serves as a center in the interior of the basic triangle Tb or the circumcenter of Tb;
default is M=c(1,1,1) i.e. the center of mass of Tb}

\item{rv1, rv2}{The indices of the vertices whose regions contains pt1 and pt2, respectively.
They take the vertex labels as 1,2,3 as in the row order of the vertices in Tb}

\item{ch.data.pnts}{A logical argument for checking whether points pt1 and pt2 are data points in Dt or not
(default is FALSE)}
}
\value{
I({pt1,pt2} is a dominating set of the PE-PCD whose vertices are the 2D data set Dt),
that is, returns 1 if {pt1,pt2} is a dominating set of PE-PCD, returns 0 otherwise
}
\description{
Returns I({pt1,pt2} is a dominating set of 2D data set Dt for PE-PCD) in the basic triangle
Tb=T(c(0,0),c(1,0),c(c1,c2)), that is, returns 1 if {pt1,pt2} is a dominating set for PE-PCD,
returns 0 otherwise. PE proximity regions are defined with respect to Tb.
In the basic triangle, Tb, c1 is in [0,1/2], c2>0 and (1-c1)^2+c2^2 <=1.
Any given triangle can be mapped to the basic triangle by a combination of rigid body motions
(i.e., translation, rotation and reflection) and scaling, preserving uniformity of the points in the
original triangle. Hence basic triangle is useful for simulation
studies under the uniformness hypothesis. Vertex regions are based on center M=(m1,m2) in Cartesian
coordinates or M=(alpha,beta,gamma) in barycentric coordinates in the interior of a basic triangle Tb;
default is M=c(1,1,1) i.e. the center of mass of Tb.
Point, pt1, is in the vertex region of vertex rv1 (default is NULL);
and point, pt2, is in the vertex region of vertex rv2 (default is NULL); vertices are labeled as 1,2,3
in the order they are stacked row-wise.
ch.data.pnts is for checking whether points pt1 and pt2 are both data points in Dt or not (default is FALSE),
so by default this function checks whether the points pt1 and pt2 would constitute a dominating set
if they both were actually in the data set.
See also (\insertCite{ceyhan:Phd-thesis,ceyhan:dom-num-NPE-Spat2011;textual}{pcds}).
}
\examples{
c1<-.4; c2<-.6;
A<-c(0,0); B<-c(1,0); C<-c(c1,c2);
Tb<-rbind(A,B,C)
n<-20

#set.seed(1)
dat<-runif.bastri(n,c1,c2)$g
#dat<-cbind(runif(n),runif(n))
#dat<-cbind(runif(n,1,2),runif(n,0,1))

M<-as.numeric(runif.bastri(1,c1,c2)$g)
#M<-c(.6,.3)
#M<-circ.cent.tri(Tb)
#M<-c(1,1,1) #M<-c(1,2,3) #M<-c(-1,2,3) #barycentric coordinates
#M<-c(1.3,1.3)
#M<-c(.3,.3)
r<-2

P<-c(.4,.2)
Gam1PEbastri(P,dat,r,c1,c2,M)
Gam1PEbastri(P,P,r,c1,c2,M)

Gam1PEbastri(dat[1,],dat,r,c1,c2,M)

Gam1PEbastri(c(1,1),dat,r,c1,c2,M)
Gam1PEbastri(c(1,1),dat,r,c1,c2,M,ch.data.pnt = TRUE)
Gam1PEbastri(c(1,1),c(1,1),r,c1,c2,M)

#or try
Rv<-rv.bastri.cent(dat[1,],c1,c2,M)$rv
Gam1PEbastri(dat[1,],dat,r,c1,c2,M,Rv)

Gam1PEbastri(c(2,1),dat,r,c1,c2,M)

Gam1PEbastri(c(.2,.1),dat,r,c1,c2,M)
Gam1PEbastri(c(.2,.1),dat,r,c1,c2,M,ch.data.pnt=TRUE)

gam.vec<-vector()
for (i in 1:n)
{gam.vec<-c(gam.vec,Gam1PEbastri(dat[i,],dat,r,c1,c2,M))}

ind.gam1<-which(gam.vec==1)
ind.gam1

Xlim<-range(Tb[,1],dat[,1])
Ylim<-range(Tb[,2],dat[,2])
xd<-Xlim[2]-Xlim[1]
yd<-Ylim[2]-Ylim[1]

if (dimension(M)==3) {M<-bary2cart(M,Tb)} #need to run this when M is given in barycentric coordinates

if (identical(M,circ.cent.tri(Tb)))
{
  plot(Tb,pch=".",asp=1,xlab="",ylab="",axes=TRUE,xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
  polygon(Tb)
  points(dat,pch=1,col=1)
  Ds<-rbind((B+C)/2,(A+C)/2,(A+B)/2)
} else
{plot(Tb,pch=".",xlab="",ylab="",axes=TRUE,xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
  polygon(Tb)
  points(dat,pch=1,col=1)
  Ds<-cp2e.bastri(c1,c2,M)}
L<-rbind(M,M,M); R<-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty=2)
points(rbind(dat[ind.gam1,]),pch=4,col=2)

txt<-rbind(Tb,M,Ds)
xc<-txt[,1]+c(-.02,.02,.02,-.02,.03,-.03,.01)
yc<-txt[,2]+c(.02,.02,.02,-.02,.02,.02,-.03)
txt.str<-c("A","B","C","M","D1","D2","D3")
text(xc,yc,txt.str)

P<-c(.4,.2)
Gam1PEbastri(P,dat,r,c1,c2,M)

Gam1PEbastri(P,rbind(dat,dat),r,c1,c2,M)
Gam1PEbastri(P,cbind(dat,dat),r,c1,c2,M)
Gam1PEbastri(P, rbind(c("a","b"),dat),r,c1,c2,M)

dat.fr<-data.frame(a=dat)
Gam1PEbastri(P,dat.fr,r,c1,c2,M)

}
\references{
\insertAllCited{}
}
\seealso{
\code{\link{Gam2PEtri}}, \code{\link{Gam2ASbastri}}, and \code{\link{Gam2AStri}}
}
