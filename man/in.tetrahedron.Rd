% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/PCDFunctions.r
\name{in.tetrahedron}
\alias{in.tetrahedron}
\title{Check whether a point is inside a tetrahedron}
\usage{
in.tetrahedron(p, th, boundary = FALSE)
}
\arguments{
\item{p}{A 3D point to be checked whether it is inside the tetrahedron or not.}

\item{th}{Four 3D points, stacked row-wise, each row representing a vertex of the tetrahedron}

\item{boundary}{A logical parameter (default=FALSE) to include boundary or not, so if it is TRUE,
the function checks if the point, p, lies in the closure of the tetrahedron (i.e. interior and boundary
combined) else it checks if p lies in the interior of the tetrahedron.}
}
\value{
A list with two elements
\item{inside.tetra}{A logical output, if the point, p, is inside the tetrahedron, Th, it is TRUE,
else it is FALSE.}
\item{barycentric}{The barycentric coordinates of the point p with respect to the tetrahedron, Th.}
}
\description{
Checks if the point p lies in the tetrahedron, th, using the barycentric coordinates, generally denoted as
(alpha,beta,gamma). If all (normalized or non-normalized) barycentric coordinates are positive then the
point p is inside the tetrahedron, if all are nonnegative with one or more are zero, then p falls on the
boundary. If some of the barycentric coordinates are negative, then p falls outside the tetrahedron.
boundary is a logical argument (default=FALSE) to include boundary or not, so if it is TRUE,
the function checks if the point, p, lies in the closure of the tetrahedron (i.e. interior and boundary
combined) else it checks if p lies in the interior of the tetrahedron.
}
\examples{
A<-c(1,10,3); B<-c(1,1,3); C<-c(3,9,12); P<-c(1,1,0)
#A<-runif(3); B<-runif(3); C<-runif(3); P<-runif(3)
#A<-runif(3,1,100); B<-runif(3,1,100); C<-runif(3,1,100); P<-runif(3,1,100)

Plane(A,B,C,.1,.2)

pts<-rbind(A,B,C,P)
paraplane(P,A,B,C,.1,.2)
paraplane(P,A,B,C,0,0)

xr<-range(pts[,1]); yr<-range(pts[,2])
xf<-(xr[2]-xr[1])*.25 #how far to go at the lower and upper ends in the x-coordinate
yf<-(yr[2]-yr[1])*.25 #how far to go at the lower and upper ends in the y-coordinate
x<-seq(xr[1]-xf,xr[2]+xf,l=100)
y<-seq(yr[1]-yf,yr[2]+yf,l=100)

plP2ABC<-paraplane(P,A,B,C,x,y)
plP2ABC
summary(plP2ABC)
plot(plP2ABC)

paraplane(P,A,B,A+B,.1,.2)

z.grid<-plP2ABC$z

plABC<-Plane(A,B,C,x,y)
plABC
pl.grid<-plABC$z

zr<-max(z.grid)-min(z.grid)
Pts<-rbind(A,B,C,P)+rbind(c(0,0,zr*.1),c(0,0,zr*.1),c(0,0,zr*.1),c(0,0,zr*.1))
Mn.pts<-apply(Pts[1:3,],2,mean)

library(plot3D)
persp3D(z = pl.grid, x = x, y = y, theta =225, phi = 30, ticktype = "detailed") #plane spanned by points A, B, C
persp3D(z = z.grid, x = x, y = y,add=TRUE) #plane parallel to the original plane and passing thru point P

persp3D(z = z.grid, x = x, y = y, theta =225, phi = 30, ticktype = "detailed") #plane spanned by points A, B, C
#add the defining points
points3D(Pts[,1],Pts[,2],Pts[,3], add=TRUE)
text3D(Pts[,1],Pts[,2],Pts[,3], c("A","B","C","P"),add=TRUE)
text3D(Mn.pts[1],Mn.pts[2],Mn.pts[3],plP2ABC$equation,add=TRUE)
polygon3D(Pts[1:3,1],Pts[1:3,2],Pts[1:3,3], add=TRUE)

P<-c(1,1,1)
paraplane(P,A,B,C,.1,.2)

}
\seealso{
\code{\link{in.triangle}}
}
