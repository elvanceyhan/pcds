% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/PCDFunctions.r
\name{runifMT}
\alias{runifMT}
\title{An object of class "Uniform"

Generation of Uniform Points in the convex hull of points}
\usage{
runifMT(n, Yp, DTmesh = NULL)
}
\arguments{
\item{n}{A positive integer representing the number of uniform points to be generated in the convex hull
of the point set Yp}

\item{Yp}{A set of 2D points whose convex hull is the support of the uniform points to be generated}

\item{DTmesh}{triangulation nodes with neigbours (result of tri.mesh function from tripack package)}
}
\value{
A list with the elements
\item{type}{The type of the pattern from which points are to be generated}
\item{mtxt}{The "main" title for the plot of the point pattern}
\item{tess.points}{The points which constitute the vertices of the triangulation and
whose convex hull determines the support of the generated points.}
\item{gen.points}{The output set of generated points uniformly in the convex hull of Yp}
\item{out.region}{The outer region which contains the support region, NULL for this function.}
\item{desc.pat}{Description of the point pattern from which points are to be generated}
\item{num.points}{The vector of two numbers, which are the number of generated points and
the number of vertices in the triangulation (i.e., size of Yp) points.}
\item{txt4pnts}{Description of the two numbers in num.points}
\item{xlimit,ylimit}{The ranges of the x- and y-coordinates of the points in Yp}
}
\description{
Generates n points uniformly in the Convex Hull of set of points, Yp. That is, generates
uniformly in each of the triangles in the Delaunay triangulation of Yp, i.e., in the multiple
triangles partitioning the convex hull of Yp.
DTmesh is the Delaunay triangulation of Yp, default is DTmesh=NULL.
DTmesh yields triangulation nodes with neigbours (result of tri.mesh function from tripack package).
See (\insertCite{okabe:2000,ceyhan:comp-geo-2010,renka:1996;textual}{pcds}) for more on Delaunay triangulation and the tripack algorithm.
}
\examples{
n<-100
dat<-runifTe(n)$gen.points
#dat<-cbind(runif(n),runif(n))
#dat<-cbind(runif(n,1,2),runif(n,0,1))

Ext<-six.ext(dat)
Ext
summary(Ext)
plot(Ext)

six.ext(dat[1:5,])$Ext
sixt<-six.ext(dat)

dat2<-rbind(dat,c(.8,.8))
six.ext(dat2)
six.ext(dat2,ch.all.intri = TRUE)

A<-c(0,0); B<-c(1,0); C<-c(0.5,sqrt(3)/2);
Te<-rbind(A,B,C)
CM<-(A+B+C)/3
D1<-(B+C)/2; D2<-(A+C)/2; D3<-(A+B)/2;
Ds<-rbind(D1,D2,D3)

h1<-c(1/2,sqrt(3)/18); h2<-c(2/3, sqrt(3)/9); h3<-c(2/3, 2*sqrt(3)/9);
h4<-c(1/2, 5*sqrt(3)/18); h5<-c(1/3, 2*sqrt(3)/9); h6<-c(1/3, sqrt(3)/9);

r1<-(h1+h6+CM)/3;r2<-(h1+h2+CM)/3;r3<-(h2+h3+CM)/3;
r4<-(h3+h4+CM)/3;r5<-(h4+h5+CM)/3;r6<-(h5+h6+CM)/3;

Xlim<-range(Te[,1],dat[,1])
Ylim<-range(Te[,2],dat[,2])
xd<-Xlim[2]-Xlim[1]
yd<-Ylim[2]-Ylim[1]

plot(A,pch=".",xlab="",ylab="",axes=TRUE,xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Te)
L<-Te; R<-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty=2)
polygon(rbind(h1,h2,h3,h4,h5,h6))
points(dat)
points(sixt$Ext,pty=2,pch=4,col="red")

txt<-rbind(Te,r1,r2,r3,r4,r5,r6)
xc<-txt[,1]+c(-.02,.02,.02,0,0,0,0,0,0)
yc<-txt[,2]+c(.02,.02,.03,0,0,0,0,0,0)
txt.str<-c("A","B","C","1","2","3","4","5","6")
text(xc,yc,txt.str)

dat.fr<-data.frame(a=dat)
six.ext(dat.fr)

}
\seealso{
\code{\link{runif.tri}}, \code{\link{runifTe}}, and \code{\link{runif.bastri}},
}
